<pre>
  BIP: 69
  Layer: Applications
  Title: Bustapay :: a practical sender/receiver coinjoin protocol
  Author: Ryan Havar <rhavar@protonmail.com>
  Comments-Summary: No comments yet.
  Comments-URI: https://github.com/bitcoin/bips/wiki/Comments:BIP-bustapay
  Status: Proposed
  Type: Informational
  Created: 2018-08-2
  License: PD
</pre>


==Abstract==

The way bitcoin transactions are generally created is known to leak more information than desirable, and as a result has lead the rise of unreasonably effective blockchain analysis which jeopardizes important properties that is expected of a currency.

Bustapay proposes a simple, practical way to send bitcoin in such a way that bust these assumptions to immediate benefit of the sender and receiver. Furthermore it does so in such a way that avoids increasing the receiver's utxo set size, a constant problem for bitcoin merchants.

==Copyright==

This BIP is in the public domain.

==Motivation==

One of the most powerful heuristics employed by those whose goal is to undermine
bitcoin's fungibility has been to assume all inputs of a transaction are signed by
a single party. In the few cases this assumption does not hold, it is generally
readily recognizable (e.g. traditional coinjoins have a very obvious structure,
or multisig funds are most frequently validated onchain).

Bustapay requires no changes to bitcoin and creates bitcoin transactions that are
indistinguishable from normal ones.

It is worth noting that this specification has been intentionally kept as simple
as possible to encourage adoption. There are almost an endless amount of extensions possible but it is the authors belief that such complexity will make it less likely for people to invest in implementing it and useful extensions are best delayed for a "v2" specification
will be created with desired extensions.

==Overview==

A bustapay payment is made from a sender to a receiver.

Step 1. Sender creates a bitcoin transaction paying the receiver

This transaction must be a valid, signed and all inputs use segwit. This transaction is known as the "template transaction". This transaction must not be propagated on the bitcoin network.

Step 2. Sender gives the "template transaction" to the receiver

Step 3. Receiver processes the transaction and returns a partially signed coinjoin

The receiver validates the transaction is valid, pays himself and is eligible for propagation. The receiver then adds one of his own inputs (known as the "contributed input") and increase the output that pays himself by the contributed input's amount. Doing so will invalidate the "template transaction"'s original input signatures, so the sender needs to return this "partial transaction" back to the receiver to sign. This is returned as a hex-encoded raw transaction a response to the original HTTP POST request.

Step 4. Receiver validates, re-signs, and propagates on the bitcoin network

The receiver is responsible in making sure the "partial transaction" returned by the sender was changed correctly (it should assume the connection is not safe and act accordingly), resign its original inputs and propagates this transaction over the bitcoin network. The client must be aware that the server can reorder inputs and outputs.

Step 5. Receiver observes the finalized transaction on the bitcoin network

Once the receiver has seen the finalized transactions on the network (and has enough confirmations) it can process it like a normal payment for the sent amount (as opposed to the amount that it looks like on the network). If the receiver does not see the finalized transaction after a timeout will propagate the original "template transaction" to ensure the payment happens and function a strong anti-DoS mechanism.

== Specification ==

The standard way of letting a sender know where to send a bustapay transaction is done via a bip21 encoded address. The key value "bpu" (short for "BustaPayUrl") should be used. An example such address would be bitcoin:2NABbUr9yeRCp1oUCtVmgJF8HGRCo3ifpTT?bpu=https://bp.bustabit.com/submit It is highly encouraged that urls are kept short.

When the sender is creating a "template transaction" it is done almost identically to creating any other transaction. The only difference is that *only* segwit inputs may be used, and should pay a mining fee as if the transaction was 102 vbytes (408 weight) larger than it as actually is.

The template transaction should be sent to the receiver via an HTTP POST. The sender may send this in hex-encoded format by adding the HTTP header: 'Content-Type: text/plain' otherwise it will be assumed the body is encoded in binary format.

The receiver is then responsible for validating the template transaction. If there is a problem with the transaction, the HTTP response code of 422 should be used and a human-readable string containing information on why which can be directly given to the user.

Should the receiver reject a transaction, it should not attempt to propagate it on the network.

== Contributed Input Choice ==
The receiver must add exactly 1 input to the transaction (the "contributed input"). If the receiver has no inputs, it should use a 500 internal server error, so the client can send the transaction as per normal (or try again later).

The contributed input must not add too much weight to transaction, so must only use a P2SH-P2WPKH input OR something that adds less transaction weight.

To prevent an attack where a receiver is continually sent variations of the same transaction to enumerate the receivers utxo set, it is essential that the receiver always returns the same contributed input when it's seen the same input.


It is strongly preferable that the receiver makes an effort to pick a contributed input of the same type as much the other transaction inputs if possible.



== Future Work ==

* Support Partially Signed Bitcoin Transaction Format
* Support receivers being able to add (and pay for) multiple inputs.
* Support for receivers to be able to sign a discounted payment amount (e.g. for merchants that want to charge less for people who use bustapay because of no consolidation costs)
* Support "bustapay-only" type addresses, for receivers who would prefer not want  transactions




P2SH-P2WPKH






This would generally be done as an HTTP POST. The exact URL to submit it to could be specified with a bip21 encoded address. Such as  and the HTTP body should be the raw transaction hex encoded as text.



=== Implementation Notes ===
For anyone wanting to implement bustapay payments, here are some notes for receivers:

* A transaction can easily be checked if it's suitable for the mempool with testmempoolaccept in bitcoin core 0.17
* Tracking transactions by txid is precarious. To keep your sanity make sure all inputs are segwit. But remember segwit does not prevent txid malleability unless you validate the transaction. So really make sure you're using testmempoolaccept at the very least
* Bustapay could be abused by a malicious party to query if you own a deposit address or not. So never accept a bustapay transaction that pays an already used deposit address
* You will need to keep a mapping of which utxos people have showed you and which you revealed. So if you see them again, you can reveal the same one of your own
* Check if the transaction was already sorted according to BIP69, if so ensure the result stays that way. Otherwise probably just shuffle the inputs/outpus

Notes for sending applications:

* The HTTP response must *not* be trusted. It should be fully validated that no unexpected changes have been made to the transaction.
* The sender should be aware the original "template transaction" may be propagated at any time, and in fact can intentionally be done so for the purpose of RBF as it should have a slightly higher fee rate.

== Credits ==
The idea is obviously based upon Dr. Maxwell's seminal CoinJoin proposal, and reduced scope inspired by a simplification of the "pay 2 endpoint" (now offline) blog post by blockstream.
